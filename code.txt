# Imports from all original files
import time
import random
import json
from datetime import datetime, timedelta # Import timedelta for time calculations
import os
import base64
import tempfile
import threading # New import for threading

from flask import Flask, jsonify, request, send_file
from flask_cors import CORS

import firebase_admin
from firebase_admin import credentials, db

import pandas as pd
import numpy as np
import tensorflow as tf
from sklearn.preprocessing import MinMaxScaler, OneHotEncoder
from sklearn.linear_model import LinearRegression
import joblib
from gtts import gTTS
import io

app = Flask(__name__)
# Explicitly enable CORS for /api routes from any origin
CORS(app, resources={r"/api/*": {"origins": "*"}}) 

# --- Global Variables for Firebase, Models, Scalers, etc. ---
firebase_app = None
model = None
input_scaler = None
output_scaler = None
crop_encoder = None
market_price_model = None
market_crop_encoder = None
market_price_features = None
all_crop_labels = []
firebase_db_ref = None # Global reference for Firebase DB
firebase_camera_ref = None # Global reference for Firebase camera feed

# Refined messages: Removed markdown and direct placeholders from dictionary values.
# The formatting will be done in the crop_care_advice_backend function.
ADVICE_MESSAGES = {
    'no_data': "No sensor data available to provide advice.",
    'npk_n_low_advice': "Consider applying nitrogen-rich fertilizer.",
    'npk_n_high_advice': "Excess nitrogen can promote leafy growth over fruit/flower development.",
    'npk_p_low_advice': "Consider applying phosphorus fertilizer for root development.",
    'npk_p_high_advice': "High phosphorus can lock up other nutrients.",
    'npk_k_low_advice': "Consider applying potassium fertilizer for overall plant health and fruit quality.",
    'npk_k_high_advice': "Excess potassium can interfere with calcium and magnesium uptake.",
    
    'wheat_sm_low_advice': "Irrigate lightly – wheat needs 35–50% soil moisture.",
    'rice_sm_low_advice': "Rice needs high moisture. Ensure proper irrigation.",
    'maize_sm_low_advice': "Maize needs moderate soil moisture levels.",
    'banana_sm_low_advice': "Keep soil consistently moist for banana.",
    'mango_sm_high_advice': "Avoid waterlogging. Mango needs well-drained soil.",
    'grapes_sm_high_advice': "Grapes prefer drier soil – avoid overwatering.",
    'cotton_sm_low_advice': "Cotton requires moderate moisture during flowering.",
    'millet_sorghum_sm_low_advice': "These are drought-resistant crops but still need minimal moisture.",
    'jute_sm_low_advice': "Jute requires ample moisture during growth.",
    'pomegranate_sm_high_advice': "Avoid overwatering pomegranate.",
    'melon_sm_low_advice': "Melons need consistent watering, especially during fruiting.",
    'coconut_sm_low_advice': "Coconut palms need high moisture levels.",
    'mothbeans_sm_low_advice': "Mothbeans are drought-tolerant but need minimal irrigation during flowering.",
    'mungbean_sm_low_advice': "Ensure regular irrigation during flowering and pod formation.",
    'blackgram_sm_low_advice': "Maintain moderate moisture especially during flowering.",
    'lentil_sm_low_advice': "Lentils need low to moderate moisture.",
    'general_sm_low_advice': "Consider irrigation to prevent drought stress.",
    'general_sm_high_advice': "Ensure good drainage to prevent waterlogging.",

    'wheat_temp_high_advice': "Provide shade or irrigate in evening – temperature is too high for wheat.",
    'rice_temp_high_advice': "It's too hot for rice. Consider evening irrigation or shade.",
    'maize_temp_low_advice': "Maize prefers warm weather (20–30°C).",
    'banana_temp_low_advice': "Banana is sensitive to cold – ensure warm conditions.",
    'mango_temp_low_advice': "Mango requires warmer temperatures (above 20°C).",
    'cotton_temp_low_advice': "Cotton thrives in warm temperatures.",
    'millet_sorghum_temp_low_advice': "Warm climate is ideal for millet and sorghum.",
    'coffee_temp_low_advice': "Coffee thrives in 18–24°C range.",
    'jute_temp_low_advice': "Jute grows well in 25–30°C.",
    'papaya_temp_low_advice': "Papaya prefers 21–33°C range.",
    'pomegranate_temp_low_advice': "Ideal temperature is above 20°C.",
    'melon_temp_low_advice': "Ensure temperature is warm (above 25°C).",
    'coconut_temp_low_advice': "Ideal temperature for coconut is above 25°C.",
    'mothbeans_temp_low_advice': "Temperature should be above 22°C.",
    'mungbean_temp_low_advice': "Mungbean requires warm conditions for optimal growth.",
    'blackgram_temp_low_advice': "Ideal temperature range is 25–35°C.",
    'lentil_temp_low_advice': "Lentils grow well in 18–30°C.",
    'general_temp_low_advice': "Cold temperatures can stunt growth. Consider protective measures.",
    'general_temp_high_advice': "High temperatures can cause heat stress. Ensure adequate water and shade.",

    'wheat_hum_high_advice': "Watch out for fungal infections – ensure good airflow.",
    'rice_hum_low_advice': "Increase ambient humidity or use mulch.",
    'banana_hum_low_advice': "Banana requires high humidity. Consider misting or mulching.",
    'grapes_hum_high_advice': "High humidity may lead to fungal infections.",
    'coffee_hum_low_advice': "Coffee prefers high humidity.",
    'orange_hum_high_advice': "Prune trees to improve airflow and prevent fungal issues.",
    'general_hum_low_advice': "Low humidity can cause wilting. Consider misting or increasing soil moisture.",
    'general_hum_high_advice': "High humidity increases risk of fungal diseases. Ensure good ventilation.",

    'wheat_ph_low_advice': "Soil is slightly acidic – consider applying lime to raise pH.",
    'rice_ph_off_advice': "Maintain slightly acidic soil for rice (pH 5.5–6.5).",
    'maize_ph_off_advice': "Maintain soil pH between 5.8–7.0.",
    'papaya_ph_low_advice': "Slightly acidic to neutral soil is best for papaya.",
    'orange_ph_off_advice': "Ideal soil pH for orange is 6.0–7.5.",
    'general_ph_very_low_advice': "Soil is too acidic. Apply lime to increase pH and improve nutrient availability.",
    'general_ph_very_high_advice': "Soil is too alkaline. Apply sulfur or organic matter to decrease pH.",
    'general_ph_off_advice': "Optimal pH range for most crops is 5.5-7.5. Adjust as needed.",

    'wheat_light_low_advice': "Ensure the crop gets enough sunlight.",
    'rice_light_low_advice': "Ensure rice gets full sun exposure.",
    'general_light_low_advice': "Insufficient light can hinder photosynthesis. Consider supplemental lighting or pruning.",
    'general_light_high_advice': "Excessive light can cause scorching. Consider shading during peak hours.",
            
    'rainfall_low_advice': "Rainfall is low. Consider irrigation.",
    'rainfall_high_advice': "Rainfall is high. Ensure proper drainage to prevent waterlogging.",

    'all_good': "All major parameters look good! Keep monitoring regularly for optimal growth."
}

# Refined messages: Removed markdown from dictionary values.
SEED_RECOMMENDATIONS_MESSAGES = {
    'intro': "Based on current conditions, you could consider: ",
    'outro': ". Consult local agricultural experts for precise recommendations.",
    'acid_tolerant': "acid-tolerant crops like blueberries, potatoes, or specific rice varieties",
    'alkaline_tolerant': "alkaline-tolerant crops such as asparagus, spinach, or specific alfalfa varieties",
    'neutral_ph': "a wide range of crops thrive in neutral to slightly acidic pH (5.5-7.5), including wheat, maize, and most vegetables",
    'heat_tolerant': "heat-tolerant crops like millet, sorghum, cotton, or some bean varieties",
    'cold_hardy': "cold-hardy crops such as winter wheat, barley, oats, or peas",
    'warm_season': "warm-season crops like maize, tropical rice, most vegetables, and fruits",
    'drought_resistant': "drought-resistant crops like millet, sorghum, chickpeas, or certain types of beans (e.g., moth beans)",
    'water_loving': "water-loving crops such as rice, sugarcane, jute, or crops that tolerate temporary waterlogging",
    'moderate_rainfall': "crops suitable for moderate rainfall, including wheat, maize, and many vegetables",
    'very_dry': "very drought-tolerant crops (e.g., desert-adapted melons or some herbs)",
    'very_wet': "semi-aquatic crops or those highly tolerant to waterlogging (e.g., taro, some rice varieties if poorly drained)",
    'no_specific': "No specific recommendations, as current conditions are unusual or general."
}


# --- Initialization Function ---
def initialize_app_components():
    """Initializes Firebase, loads AI model, scalers, and crop encoder."""
    global firebase_app, model, input_scaler, output_scaler, crop_encoder, \
           market_price_model, market_crop_encoder, market_price_features, all_crop_labels, \
           firebase_db_ref, firebase_camera_ref

    # --- Firebase Secure Setup ---
    firebase_key_b64 = os.getenv("FIREBASE_KEY_B64")
    firebase_cred_path = None
    
    print("Attempting Firebase initialization...")
    try:
        if not firebase_admin._apps: # Prevent double initialization
            print("Firebase app not already initialized. Proceeding with initialization.")
            if firebase_key_b64:
                print("FIREBASE_KEY_B64 environment variable found. Decoding credentials.")
                decoded_json = base64.b64decode(firebase_key_b64).decode('utf-8')
                # Use tempfile to create a temporary file for the credentials
                with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.json') as f:
                    f.write(decoded_json)
                firebase_cred_path = f.name
                cred = credentials.Certificate(firebase_cred_path)
                print("Firebase credentials loaded from environment variable.")
            else:
                print("FIREBASE_KEY_B64 not found. Attempting to load from local file.")
                # Fallback for local development if environment variable is not set
                # Ensure 'agriastrax-website-firebase-adminsdk-fbsvc-36cdff39c2.json' is in your project root
                cred = credentials.Certificate("agriastrax-website-firebase-adminsdk-fbsvc-36cdff39c2.json")
                print("Firebase credentials loaded from local file.")
            
            print("Calling firebase_admin.initialize_app...")
            firebase_app = firebase_admin.initialize_app(cred, {
                'databaseURL': 'https://agriastrax-website-default-rtdb.firebaseio.com/'
            })
            print("Firebase initialized successfully.")
        else:
            firebase_app = firebase_admin.get_app() # Get existing app if already initialized
            print("Firebase already initialized (skipped re-initialization).")

        firebase_db_ref = db.reference('sensors/farm1')
        firebase_camera_ref = db.reference('camera_feed/farm1')
        print("Firebase database references obtained.")

    except Exception as e:
        print(f"❌ Firebase initialization failed: {e}")
        firebase_app = None # Mark as failed
        firebase_db_ref = None
        firebase_camera_ref = None
    finally:
        # Clean up the temporary file if it was created
        if firebase_key_b64 and firebase_cred_path and os.path.exists(firebase_cred_path):
            try:
                os.remove(firebase_cred_path)
                print(f"Cleaned up temporary Firebase cred file: {firebase_cred_path}")
            except Exception as e_clean:
                print(f"Warning: Could not delete temporary Firebase cred file {firebase_cred_path}: {e_clean}")


    # --- Load Crop Labels from CSV ---
    try:
        # Assuming 'cleaned_sensor_data.csv' is available in the same directory as app.py
        crop_df_for_labels = pd.read_csv("cleaned_sensor_data.csv")
        all_crop_labels = sorted(crop_df_for_labels['label'].unique().tolist())
        crop_encoder = OneHotEncoder(handle_unknown='ignore', sparse_output=False)
        crop_encoder.fit(np.array(all_crop_labels).reshape(-1, 1))
        market_crop_encoder = crop_encoder # Use the same encoder for market price
        print(f"Crop labels loaded: {len(all_crop_labels)} unique crops found.")
    except FileNotFoundError:
        print("❌ 'cleaned_sensor_data.csv' not found. Crop labels and encoder will be limited or empty.")
        all_crop_labels = []
        crop_encoder = OneHotEncoder(handle_unknown='ignore', sparse_output=False) # Fallback
        market_crop_encoder = crop_encoder
    except Exception as e:
        print(f"❌ Error loading 'cleaned_sensor_data.csv': {e}")
        all_crop_labels = []
        crop_encoder = OneHotEncoder(handle_unknown='ignore', sparse_output=False) # Fallback
        market_crop_encoder = crop_encoder

    # --- Load AI Model ---
    try:
        # Assuming 'tdann_pnsm_model.keras' is available
        model = tf.keras.models.load_model("tdann_pnsm_model.keras")
        print("AI model (tdann_pnsm_model.keras) loaded successfully.")
    except Exception as e:
        print(f"❌ Error loading AI model (tdann_pnsm_model.keras): {e}")
        model = None

    # --- Load Scalers ---
    try:
        # Assuming scaler files are available
        input_scaler = joblib.load('tdann_input_scaler.joblib')
        output_scaler = joblib.load('tdann_output_scaler.joblib')
        print("Input and Output scalers loaded successfully.")
    except FileNotFoundError:
        print("❌ Scaler files (tdann_input_scaler.joblib, tdann_output_scaler.joblib) not found.")
        input_scaler = MinMaxScaler() # Fallback
        output_scaler = MinMaxScaler() # Fallback
        print("Using newly initialized scalers. Predictions may be inaccurate.")
    except Exception as e:
        print(f"❌ Error loading scalers: {e}")
        input_scaler = MinMaxScaler() # Fallback
        output_scaler = MinMaxScaler() # Fallback
        print("Using newly initialized scalers. Predictions may be inaccurate.")

    # --- Market Price Predictor Setup ---
    def generate_market_price_data(num_samples=1000):
        data = []
        crops = all_crop_labels if all_crop_labels else ['wheat', 'rice', 'maize']
        
        for _ in range(num_samples):
            crop_type = random.choice(crops)
            N = random.uniform(50, 150)
            P = random.uniform(20, 60)
            K = random.uniform(50, 200)
            temperature = random.uniform(20, 35)
            humidity = random.uniform(30, 80)
            
            base_price = 100
            
            if crop_type == 'wheat':
                price = base_price * 1.2
            elif crop_type == 'rice':
                price = base_price * 1.5
            elif crop_type == 'maize':
                price = base_price * 1.1
            else: 
                price = base_price * 1.0
                
            price += (N / 10) + (P / 5) + (K / 10)
            price += (temperature - 25) * 2
            price += (humidity - 50) * 1.5
            
            price += random.uniform(-10, 10)
            price = max(50, price)
            
            data.append([N, P, K, temperature, humidity, crop_type, price])
            
        df_prices = pd.DataFrame(data, columns=['N', 'P', 'K', 'temperature', 'humidity', 'crop_type', 'price'])
        return df_prices

    if crop_encoder: # Ensure crop_encoder is available for market price model training
        df_prices = generate_market_price_data(num_samples=2000)
        market_price_features = ['N', 'P', 'K', 'temperature', 'humidity']
        
        # Ensure crop_encoder is fitted with 'crop_type' if it's used here
        X_categorical = market_crop_encoder.transform(df_prices[['crop_type']])
        X_categorical_df = pd.DataFrame(X_categorical, columns=market_crop_encoder.get_feature_names_out(['crop_type']))
        
        X_numerical = df_prices[market_price_features]
        
        X_train_market = pd.concat([X_numerical, X_categorical_df], axis=1)
        y_train_market = df_prices['price']
        
        market_price_model = LinearRegression()
        market_price_model.fit(X_train_market, y_train_market)
        print("Market price prediction model trained (simulated data).")
    else:
        print("❌ Cannot train market price model: Crop encoder not initialized.")


# --- Data Simulation Functions (Integrated from dummy_camera_simulator.py and insert-sample-data.py) ---

# Simulated growth stages
growth_stages = ["Germination", "Vegetative", "Flowering", "Maturity", "Wilting", "Yellowing"]
# Define possible crop stages for sensor data
CROP_STAGES = ['seed', 'sprout', 'vegetative', 'flowering', 'mature']

def generate_dummy_growth_event():
    """Generates a single dummy camera feed event."""
    event = {
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "stage": random.choice(growth_stages),
        "alert": random.choice([
            "Healthy Growth",
            "Low Leaf Color Index",
            "Possible Disease Detected",
            "Needs Fertilizer",
            "Check Irrigation"
        ])
    }
    return event

def run_camera_simulator():
    """Simulates camera feed data and pushes to Firebase."""
    print("Starting dummy camera feed simulation thread...")
    if firebase_camera_ref is None:
        print("Firebase camera reference not initialized. Camera simulation will only print locally.")
        local_print_only = True
    else:
        local_print_only = False
        print("Connected to Firebase path for camera feed: camera_feed/farm1")

    while True:
        event = generate_dummy_growth_event()
        
        if not local_print_only:
            try:
                firebase_camera_ref.push(event)
                # print(f"Simulated Camera Data pushed to Firebase: {event}") # Too verbose for continuous run
            except Exception as e:
                print(f"❌ Error pushing camera data to Firebase: {e}. Falling back to local printing.")
                local_print_only = True # Stop trying to push to Firebase
                print("Simulated Camera Data (local print):", event)
        else:
            print("Simulated Camera Data (local print):", event)

        time.sleep(10)  # Generate every 10 seconds

def run_sensor_data_inserter():
    """Inserts initial dummy sensor data and then simulates live updates to Firebase."""
    print("Starting sensor data inserter thread...")
    if firebase_db_ref is None:
        print("Firebase DB reference not initialized. Sensor data insertion will only print locally.")
        local_print_only = True
    else:
        local_print_only = False
        print("Connected to Firebase path for sensor data: sensors/farm1")

    # Insert 10 past samples
    print("Inserting 10 enhanced dummy sensor readings with all 12 features (including crop_stage and growth_factor)...")
    for i in range(10):
        sample_data = {
            'timestamp': (datetime.now() - timedelta(minutes=(10 - i)*5)).isoformat(),
            'soil_moisture': round(random.uniform(20, 80), 2),
            'temperature': round(random.uniform(20, 40), 2), # Wider range
            'humidity': round(random.uniform(30, 95), 2), # Wider range
            'pH': round(random.uniform(4.0, 9.0), 2), 
            'light_intensity': random.randint(200, 900), # Wider range
            'N': random.randint(0, 150), # Wider range
            'P': random.randint(0, 70), # Wider range
            'K': random.randint(0, 250), # Wider range
            'rainfall': round(random.uniform(0, 250), 2), # Wider range
            'crop_stage': random.choice(CROP_STAGES),
            'growth_factor': round(random.uniform(0.1, 1.2), 2) # Wider range for more visible change
        }
        if not local_print_only:
            try:
                firebase_db_ref.push(sample_data)
            except Exception as e:
                print(f"❌ Error pushing initial sample data to Firebase: {e}. Falling back to local printing.")
                local_print_only = True
                print("Initial Sample Data (local print):", sample_data)
                break # Stop inserting if there's an error
        else:
            print("Initial Sample Data (local print):", sample_data)
    print("Successfully inserted 10 enhanced dummy sensor readings (if Firebase was available).")

    # Simulate live updates every 10s
    print("\nSimulating live sensor data updates. New data will be inserted every 10 seconds. Press Ctrl+C to stop.")
    while True:
        current_timestamp = datetime.now().isoformat()
        
        current_soil_moisture = round(random.uniform(20, 60), 2)
        current_temperature = round(random.uniform(20, 40), 2) # Wider range
        current_humidity = round(random.uniform(30, 95), 2) # Wider range
        current_pH = round(random.uniform(4.0, 9.0), 2) # Wider range
        current_light_intensity = random.randint(200, 900) # Wider range
        current_N = random.randint(0, 150) # Wider range
        current_P = random.randint(0, 70) # Wider range
        current_K = random.randint(0, 250) # Wider range
        current_rainfall = round(random.uniform(0, 250), 2) # Wider range
        
        current_crop_stage = random.choice(CROP_STAGES) 
        
        # Make growth factor more visibly dynamic
        current_growth_factor = round(random.uniform(0.1, 1.2), 2) # Directly random for more variation

        live_data = {
            'timestamp': current_timestamp,
            'soil_moisture': current_soil_moisture,
            'temperature': current_temperature,
            'humidity': current_humidity,
            'pH': current_pH, 
            'light_intensity': current_light_intensity,
            'N': current_N,
            'P': current_P,
            'K': current_K,
            'rainfall': current_rainfall,
            'crop_stage': current_crop_stage,
            'growth_factor': current_growth_factor
        }

        if not local_print_only:
            try:
                firebase_db_ref.push(live_data)
                # print(f"Inserted real-time enriched sensor data at {current_timestamp}.") # Too verbose
            except Exception as e:
                print(f"❌ Error pushing real-time data to Firebase: {e}. Falling back to local printing.")
                local_print_only = True
                print("Live Sensor Data (local print):", live_data)
        else:
            print("Live Sensor Data (local print):", live_data)
            
        time.sleep(10)

# --- Helper Functions (adapted from original app.py) ---

def fetch_sensor_data_backend():
    """Fetches sensor data from Firebase Realtime Database."""
    if firebase_db_ref is None:
        print("Firebase DB reference not initialized. Cannot fetch sensor data.")
        return pd.DataFrame()
    try:
        snapshot = firebase_db_ref.get()
        if not snapshot:
            return pd.DataFrame()
        
        if isinstance(snapshot, dict):
            data_list = []
            for key, value in snapshot.items():
                if isinstance(value, dict):
                    data_list.append(value)
                else:
                    print(f"Skipping non-dict entry in Firebase sensor data: {key}: {value}")
            df = pd.DataFrame(data_list)
        else:
            df = pd.DataFrame(snapshot)

        if df.empty:
            return pd.DataFrame()

        numeric_cols = ['N', 'P', 'K', 'pH', 'rainfall', 'temperature', 'humidity', 
                        'soil_moisture', 'light_intensity', 'growth_factor']
        for col in numeric_cols:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')
            else:
                df[col] = np.nan
        
        if 'pH' in df.columns and 'ph' not in df.columns:
            df['ph'] = df['pH']
        if 'pH' in df.columns:
            df = df.drop(columns=['pH'])

        if 'ph' in df.columns and df['ph'].isnull().any():
            df['ph'] = df['ph'].fillna(6.5) 

        df['timestamp'] = pd.to_datetime(df['timestamp'], errors='coerce')
        df = df.dropna(subset=['timestamp'])
        df = df.sort_values('timestamp')
        return df.reset_index(drop=True)
    except Exception as e:
        print(f"Error fetching sensor data from Firebase: {e}")
        return pd.DataFrame()

def fetch_camera_feed_data_backend():
    """Fetches camera feed data (growth events) from Firebase Realtime Database."""
    if firebase_camera_ref is None:
        print("Firebase camera reference not initialized. Cannot fetch camera data.")
        return None
    try:
        snapshot = firebase_camera_ref.get()
        if not snapshot:
            return None
        
        if isinstance(snapshot, dict):
            last_key = sorted(snapshot.keys())[-1]
            return snapshot[last_key]
        else:
            if isinstance(snapshot, list) and snapshot:
                return snapshot[-1]
            return None
    except Exception as e:
        print(f"Error fetching camera feed data from Firebase: {e}")
        return None

def predict_growth_backend(df_latest_data, selected_crop_type):
    """
    Predicts soil moisture, light intensity, and nutrient sum using the loaded AI model.
    Assumes the model was trained with specific input features and multiple outputs.
    """
    if model is None or input_scaler is None or output_scaler is None or crop_encoder is None:
        return None, None, None, "AI model, scalers, or encoder not loaded."
    
    LOOKBACK_WINDOW = 5
    
    base_sensor_features = ['N', 'P', 'K', 'temperature', 'humidity', 'ph', 'rainfall']
    biological_features = ['growth_factor']
    
    present_biological_features = [f for f in biological_features if f in df_latest_data.columns]
    final_tdann_input_features = base_sensor_features + present_biological_features

    available_tdann_features = [f for f in final_tdann_input_features if f in df_latest_data.columns]
    
    if len(available_tdann_features) != len(final_tdann_input_features):
        missing = set(final_tdann_input_features) - set(available_tdann_features)
        return None, None, None, f"Missing expected TDANN input features in sensor data: {list(missing)}. Ensure Firebase is sending all required sensor data."

    processed_data_for_prediction = df_latest_data[available_tdann_features].tail(LOOKBACK_WINDOW)
    processed_data_for_prediction = processed_data_for_prediction.fillna(method='ffill').fillna(method='bfill').fillna(0)

    if len(processed_data_for_prediction) < LOOKBACK_WINDOW:
        return None, None, None, f"Not enough complete data points ({len(processed_data_for_prediction)} < {LOOKBACK_WINDOW}) even after filling NaNs. Need at least {LOOKBACK_WINDOW} consecutive entries with non-NaNs initially."

    encoded_crop_feature_names = crop_encoder.get_feature_names_out(['label'])
    
    full_input_features_sequence = []
    
    crop_type_input = np.array([selected_crop_type]).reshape(-1, 1)
    encoded_crop_single = crop_encoder.transform(crop_type_input)

    for i in range(LOOKBACK_WINDOW):
        numerical_features_at_timestep = processed_data_for_prediction.iloc[i][available_tdann_features].values
        combined_features_at_timestep = np.hstack((numerical_features_at_timestep, encoded_crop_single[0]))
        full_input_features_sequence.append(combined_features_at_timestep)

    full_input_features_sequence_np = np.array(full_input_features_sequence)
    
    try:
        scaled_input_sequence = input_scaler.transform(full_input_features_sequence_np)
        X_predict = scaled_input_sequence.reshape(1, LOOKBACK_WINDOW, scaled_input_sequence.shape[1])
        predicted_scaled_outputs = model.predict(X_predict, verbose=0)
        predicted_raw_outputs = output_scaler.inverse_transform(predicted_scaled_outputs)
        
        soil_moisture_pred = round(float(predicted_raw_outputs[0][0]), 2)
        light_intensity_pred = round(float(predicted_raw_outputs[0][1]), 2)
        nutrient_sum_pred = round(float(predicted_raw_outputs[0][2]), 2)
        
        return soil_moisture_pred, light_intensity_pred, nutrient_sum_pred, None
    except Exception as e:
        print(f"Error during AI prediction: {e}")
        return None, None, None, f"Error during AI prediction: {e}"

def predict_market_price_backend(latest_data, selected_crop_type):
    """
    Predicts the market price based on latest sensor data and crop type.
    """
    if market_price_model is None or market_crop_encoder is None or market_price_features is None:
        return None, "Market prediction model, encoder, or features not initialized."

    if not latest_data:
        return None, "No latest sensor data available for market price prediction."

    input_values = {}
    for feature in market_price_features:
        val = latest_data.get(feature)
        if val is not None and not pd.isna(val):
            input_values[feature] = val
        else:
            print(f"Missing or NaN feature '{feature}' for market price prediction. Imputing with 0.")
            input_values[feature] = 0
    
    input_df_numerical = pd.DataFrame([input_values])
    
    crop_type_input = np.array([selected_crop_type]).reshape(-1, 1)
    encoded_crop = market_crop_encoder.transform(crop_type_input)
    encoded_crop_df = pd.DataFrame(encoded_crop, columns=market_crop_encoder.get_feature_names_out(['crop_type']))
    
    X_predict_market = pd.concat([input_df_numerical, encoded_crop_df], axis=1)
    
    try:
        predicted_price = market_price_model.predict(X_predict_market)[0]
        return round(predicted_price, 2), None
    except Exception as e:
        print(f"Error during market price prediction: {e}")
        return None, f"Error during market price prediction: {e}"

def crop_care_advice_backend(df, crop_type):
    """Provides crop-specific care advice based on latest sensor readings."""
    messages = ADVICE_MESSAGES

    if df.empty:
        return [messages['no_data']]
    
    latest = df.iloc[-1].to_dict()
    tips = []
    
    ct = crop_type.lower()

    # NPK Advice
    npk_advice_map = {
        'N': {'min': 50, 'max': 150, 'low_key': 'npk_n_low_advice', 'high_key': 'npk_n_high_advice'},
        'P': {'min': 20, 'max': 60, 'low_key': 'npk_p_low_advice', 'high_key': 'npk_p_high_advice'},
        'K': {'min': 50, 'max': 200, 'low_key': 'npk_k_low_advice', 'high_key': 'npk_k_high_advice'},
    }

    for nutrient, thresholds in npk_advice_map.items():
        if nutrient in latest and not pd.isna(latest.get(nutrient)):
            value = latest[nutrient]
            if value < thresholds['min']:
                tips.append(f"🌱 {nutrient} is low ({value:.1f}). {messages[thresholds['low_key']]}")
            elif value > thresholds['max']:
                tips.append(f"🌱 {nutrient} is high ({value:.1f}). {messages[thresholds['high_key']]}")

    # Soil Moisture Advice
    if 'soil_moisture' in latest and not pd.isna(latest.get('soil_moisture')):
        sm = latest['soil_moisture']
        sm_msg_prefix = f"💧 Soil Moisture is {sm:.1f}%."
        if ct == 'wheat':
            if sm < 35: tips.append(f"{sm_msg_prefix} {messages['wheat_sm_low_advice']}")
        elif ct == 'rice':
            if sm < 60: tips.append(f"{sm_msg_prefix} {messages['rice_sm_low_advice']}")
        elif ct == 'maize':
            if sm < 40: tips.append(f"{sm_msg_prefix} {messages['maize_sm_low_advice']}")
        elif ct == 'banana':
            if sm < 50: tips.append(f"{sm_msg_prefix} {messages['banana_sm_low_advice']}")
        elif ct == 'mango':
            if sm > 60: tips.append(f"{sm_msg_prefix} {messages['mango_sm_high_advice']}")
        elif ct == 'grapes':
            if sm > 50: tips.append(f"{sm_msg_prefix} {messages['grapes_sm_high_advice']}")
        elif ct == 'cotton':
            if sm < 30: tips.append(f"{sm_msg_prefix} {messages['cotton_sm_low_advice']}")
        elif ct == 'millet' or ct == 'sorghum':
            if sm < 25: tips.append(f"{sm_msg_prefix} {messages['millet_sorghum_sm_low_advice']}")
        elif ct == 'jute':
            if sm < 50: tips.append(f"{sm_msg_prefix} {messages['jute_sm_low_advice']}")
        elif ct == 'pomegranate':
            if sm > 50: tips.append(f"{sm_msg_prefix} {messages['pomegranate_sm_high_advice']}")
        elif ct == 'muskmelon' or ct == 'watermelon':
            if sm < 30: tips.append(f"{sm_msg_prefix} {messages['melon_sm_low_advice']}")
        elif ct == 'coconut':
            if sm < 50: tips.append(f"{sm_msg_prefix} {messages['coconut_sm_low_advice']}")
        elif ct == 'mothbeans':
            if sm < 25: tips.append(f"{sm_msg_prefix} {messages['mothbeans_sm_low_advice']}")
        elif ct == 'mungbean':
            if sm < 30: tips.append(f"{sm_msg_prefix} {messages['mungbean_sm_low_advice']}")
        elif ct == 'blackgram':
            if sm < 35: tips.append(f"{sm_msg_prefix} {messages['blackgram_sm_low_advice']}")
        elif ct == 'lentil':
            if sm < 25: tips.append(f"{sm_msg_prefix} {messages['lentil_sm_low_advice']}")
        if sm < 30: tips.append(f"{sm_msg_prefix} {messages['general_sm_low_advice']}")
        elif sm > 70: tips.append(f"{sm_msg_prefix} {messages['general_sm_high_advice']}")

    # Temperature Advice
    if 'temperature' in latest and not pd.isna(latest.get('temperature')):
        temp = latest['temperature']
        temp_msg_prefix = f"🌡️ Temperature is {temp:.1f}°C."
        if ct == 'wheat':
            if temp > 32: tips.append(f"{temp_msg_prefix} {messages['wheat_temp_high_advice']}")
        elif ct == 'rice':
            if temp > 38: tips.append(f"{temp_msg_prefix} {messages['rice_temp_high_advice']}")
        elif ct == 'maize':
            if temp < 20: tips.append(f"{temp_msg_prefix} {messages['maize_temp_low_advice']}")
        elif ct == 'banana':
            if temp < 15: tips.append(f"{temp_msg_prefix} {messages['banana_temp_low_advice']}")
        elif ct == 'mango':
            if temp < 20: tips.append(f"{temp_msg_prefix} {messages['mango_temp_low_advice']}")
        elif ct == 'cotton':
            if temp < 20: tips.append(f"{temp_msg_prefix} {messages['cotton_temp_low_advice']}")
        elif ct == 'millet' or ct == 'sorghum':
            if temp < 20: tips.append(f"{temp_msg_prefix} {messages['millet_sorghum_temp_low_advice']}")
        elif ct == 'coffee':
            if temp < 18: tips.append(f"{temp_msg_prefix} {messages['coffee_temp_low_advice']}")
        elif ct == 'jute':
            if temp < 25: tips.append(f"{temp_msg_prefix} {messages['jute_temp_low_advice']}")
        elif ct == 'papaya':
            if temp < 20: tips.append(f"{temp_msg_prefix} {messages['papaya_temp_low_advice']}") 
        elif ct == 'pomegranate':
            if temp < 20: tips.append(f"{temp_msg_prefix} {messages['pomegranate_temp_low_advice']}")
        elif ct == 'muskmelon' or ct == 'watermelon':
            if temp < 25: tips.append(f"{temp_msg_prefix} {messages['melon_temp_low_advice']}")
        elif ct == 'coconut':
            if temp < 25: tips.append(f"{temp_msg_prefix} {messages['coconut_temp_low_advice']}")
        elif ct == 'mothbeans':
            if temp < 22: tips.append(f"{temp_msg_prefix} {messages['mothbeans_temp_low_advice']}")
        elif ct == 'mungbean':
            if temp < 20: tips.append(f"{temp_msg_prefix} {messages['mungbean_temp_low_advice']}")
        elif ct == 'blackgram':
            if temp < 18: tips.append(f"{temp_msg_prefix} {messages['blackgram_temp_low_advice']}")
        elif ct == 'lentil':
            if temp < 15: tips.append(f"{temp_msg_prefix} {messages['lentil_temp_low_advice']}")
        if temp < 18: tips.append(f"{temp_msg_prefix} {messages['general_temp_low_advice']}")
        elif temp > 35: tips.append(f"{temp_msg_prefix} {messages['general_temp_high_advice']}")

    # Humidity Advice
    if 'humidity' in latest and not pd.isna(latest.get('humidity')):
        hum = latest['humidity']
        hum_msg_prefix = f"💨 Humidity is {hum:.1f}%."
        if ct == 'wheat':
            if hum > 70: tips.append(f"{hum_msg_prefix} {messages['wheat_hum_high_advice']}")
        elif ct == 'rice':
            if hum < 60: tips.append(f"{hum_msg_prefix} {messages['rice_hum_low_advice']}")
        elif ct == 'banana':
            if hum < 60: tips.append(f"{hum_msg_prefix} {messages['banana_hum_low_advice']}")
        elif ct == 'grapes':
            if hum > 70: tips.append(f"{hum_msg_prefix} {messages['grapes_hum_high_advice']}")
        elif ct == 'coffee':
            if hum < 60: tips.append(f"{hum_msg_prefix} {messages['coffee_hum_low_advice']}")
        elif ct == 'orange':
            if hum > 70: tips.append(f"{hum_msg_prefix} {messages['orange_hum_high_advice']}")
        if hum < 40: tips.append(f"{hum_msg_prefix} {messages['general_hum_low_advice']}")
        elif hum > 80: tips.append(f"{hum_msg_prefix} {messages['general_hum_high_advice']}")

    # pH Advice
    if 'ph' in latest and not pd.isna(latest.get('ph')):
        ph_val = latest['ph']
        ph_msg_prefix = f"🧪 pH is {ph_val:.1f}."
        if ct == 'wheat':
            if ph_val < 6.0: tips.append(f"{ph_msg_prefix} {messages['wheat_ph_low_advice']}")
        elif ct == 'rice':
            if ph_val < 5.5 or ph_val > 6.5: tips.append(f"{ph_msg_prefix} {messages['rice_ph_off_advice']}")
        elif ct == 'maize':
            if ph_val < 5.8 or ph_val > 7: tips.append(f"{ph_msg_prefix} {messages['maize_ph_off_advice']}")
        elif ct == 'papaya':
            if ph_val < 6: tips.append(f"{ph_msg_prefix} {messages['papaya_ph_low_advice']}")
        elif ct == 'orange':
            if ph_val < 6 or ph_val > 7.5: tips.append(f"{ph_msg_prefix} {messages['orange_ph_off_advice']}")
        if ph_val < 5.5: tips.append(f"{ph_msg_prefix} {messages['general_ph_very_low_advice']}")
        elif ph_val > 7.5: tips.append(f"{ph_msg_prefix} {messages['general_ph_very_high_advice']}")
        elif not (5.5 <= ph_val <= 7.5): tips.append(f"{ph_msg_prefix} {messages['general_ph_off_advice']}")

    # Light Intensity Advice
    if 'light_intensity' in latest and not pd.isna(latest.get('light_intensity')):
        light = latest['light_intensity']
        light_msg_prefix = f"☀️ Light Intensity is {light:.1f} lux."
        if ct == 'wheat':
            if light < 400: tips.append(f"{light_msg_prefix} {messages['wheat_light_low_advice']}")
        elif ct == 'rice':
            if light < 500: tips.append(f"{light_msg_prefix} {messages['rice_light_low_advice']}")
        if light < 300: tips.append(f"{light_msg_prefix} {messages['general_light_low_advice']}")
        elif light > 800: tips.append(f"{light_msg_prefix} {messages['general_light_high_advice']}")
            
    # Rainfall Advice
    if 'rainfall' in latest and not pd.isna(latest.get('rainfall')):
        rain = latest['rainfall']
        rain_msg_prefix = f"🌧️ Rainfall is {rain:.1f} mm."
        if rain < 50: 
            tips.append(f"{rain_msg_prefix} {messages['rainfall_low_advice']}")
        elif rain > 200: 
            tips.append(f"{rain_msg_prefix} {messages['rainfall_high_advice']}")
        
    return tips if tips else [messages['all_good']]

def recommend_seeds_backend(ph, temperature, rainfall, soil_moisture=None):
    """
    Suggests suitable crops based on environmental conditions.
    """
    messages = SEED_RECOMMENDATIONS_MESSAGES
    recommendations = []

    if ph is not None:
        if ph < 5.5:
            recommendations.append(messages['acid_tolerant'])
        elif ph > 7.5:
            recommendations.append(messages['alkaline_tolerant'])
        else:
            recommendations.append(messages['neutral_ph'])

    if temperature is not None:
        if temperature > 35:
            recommendations.append(messages['heat_tolerant'])
        elif temperature < 15:
            recommendations.append(messages['cold_hardy'])
        else:
            recommendations.append(messages['warm_season'])

    if rainfall is not None:
        if rainfall < 50:
            recommendations.append(messages['drought_resistant'])
        elif rainfall > 200:
            recommendations.append(messages['water_loving'])
        else:
            recommendations.append(messages['moderate_rainfall'])

    if soil_moisture is not None:
        if soil_moisture < 30:
            recommendations.append(messages['very_dry'])
        elif soil_moisture > 80:
            recommendations.append(messages['very_wet'])

    if not recommendations:
        return messages['no_specific']
    
    return messages['intro'] + ", ".join(recommendations) + messages['outro']

def speak_tip_backend(text, lang='en'):
    """Generates speech from text using gTTS and returns audio bytes."""
    try:
        tts = gTTS(text=text, lang=lang, slow=False)
        fp = io.BytesIO()
        tts.write_to_fp(fp)
        fp.seek(0)
        return fp.getvalue(), None
    except Exception as e:
        print(f"Error generating speech with gTTS for language '{lang}': {e}")
        return None, f"Error generating speech: {e}"

# --- Flask Routes ---

@app.route('/')
def index():
    return send_file('index.html')

@app.route('/api/data')
def get_dashboard_data():
    """Fetches all data required for the dashboard."""
    df = fetch_sensor_data_backend()
    latest_data = {}
    if not df.empty:
        latest_data = df.iloc[-1].to_dict()
        # Convert Timestamp objects to string for JSON serialization
        # And convert any numpy NaN values to None for proper JSON serialization
        for key, value in latest_data.items():
            if isinstance(value, pd.Timestamp):
                latest_data[key] = value.isoformat()
            elif pd.isna(value): # Check for numpy NaN
                latest_data[key] = None

    camera_data = fetch_camera_feed_data_backend()
    
    # Prepare data for plotting sensor trends
    plot_features = ['soil_moisture', 'temperature', 'humidity', 'ph', 'light_intensity', 'N', 'P', 'K', 'rainfall', 'growth_factor']
    existing_plot_features = [f for f in plot_features if f in df.columns]

    plot_data_list = []
    if not df.empty and len(existing_plot_features) > 0:
        plot_df_melted = df.dropna(subset=existing_plot_features + ['timestamp']).melt(
            id_vars=['timestamp'], 
            value_vars=existing_plot_features,
            var_name='Sensor Metric',
            value_name='Reading'
        )
        # Convert timestamps to string for JSON
        plot_df_melted['timestamp'] = plot_df_melted['timestamp'].dt.strftime('%Y-%m-%dT%H:%M:%S')
        
        # Convert any NaN in the 'Reading' column to None
        plot_df_melted['Reading'] = plot_df_melted['Reading'].apply(lambda x: None if pd.isna(x) else x)

        plot_data_list = plot_df_melted.to_dict(orient='records')

    # Prepare raw data table
    raw_data_list = []
    if not df.empty:
        # Convert timestamps to string for JSON
        df_raw = df.tail(10).copy()
        if 'timestamp' in df_raw.columns:
            df_raw['timestamp'] = df_raw['timestamp'].apply(lambda x: x.isoformat())
        
        # Convert any NaN in the entire DataFrame to None for JSON serialization
        # This is a more robust way to handle NaNs for the raw data table
        raw_data_list = df_raw.replace({np.nan: None}).to_dict(orient='records')

    return jsonify({
        'latest_data': latest_data,
        'camera_data': camera_data,
        'plot_data': plot_data_list,
        'raw_data': raw_data_list,
        'crop_labels': all_crop_labels,
        'status': 'success' if not df.empty else 'no_data'
    })

@app.route('/api/predict_growth', methods=['POST'])
def api_predict_growth():
    data = request.get_json()
    selected_crop_type = data.get('selected_crop_type')
    
    df = fetch_sensor_data_backend()
    if df.empty:
        return jsonify({'error': 'No sensor data available for prediction.'}), 400

    soil_moisture_pred, light_intensity_pred, nutrient_sum_pred, error_msg = predict_growth_backend(df, selected_crop_type)
    
    if error_msg:
        return jsonify({'error': error_msg}), 500
    
    return jsonify({
        'soil_moisture_pred': soil_moisture_pred,
        'light_intensity_pred': light_intensity_pred,
        'nutrient_sum_pred': nutrient_sum_pred
    })

@app.route('/api/market_price', methods=['POST'])
def api_market_price():
    data = request.get_json()
    selected_crop_type = data.get('selected_crop_type')

    df = fetch_sensor_data_backend()
    if df.empty:
        return jsonify({'error': 'No sensor data available for market price prediction.'}), 400
    
    latest_sensor_data_for_price = df.iloc[-1].to_dict()
    predicted_price, error_msg = predict_market_price_backend(latest_sensor_data_for_price, selected_crop_type)

    if error_msg:
        return jsonify({'error': error_msg}), 500

    return jsonify({'predicted_price': predicted_price})

@app.route('/api/care_advice', methods=['POST'])
def api_care_advice():
    data = request.get_json()
    selected_crop_type = data.get('selected_crop_type')

    df = fetch_sensor_data_backend()
    if df.empty:
        return jsonify({'advice': [ADVICE_MESSAGES['no_data']]})

    care_tips = crop_care_advice_backend(df, selected_crop_type)
    return jsonify({'advice': care_tips})

@app.route('/api/seed_recommendations', methods=['POST'])
def api_seed_recommendations():
    data = request.get_json()
    soil_moisture_pred = data.get('soil_moisture_pred')

    df = fetch_sensor_data_backend()
    if df.empty:
        return jsonify({'recommendation': SEED_RECOMMENDATIONS_MESSAGES['no_specific']})

    latest_sensor_data_for_suggestion = df.iloc[-1].to_dict()
    current_ph = latest_sensor_data_for_suggestion.get('ph') 
    current_temp = latest_sensor_data_for_suggestion.get('temperature')
    current_rainfall = latest_sensor_data_for_suggestion.get('rainfall')

    current_ph = None if pd.isna(current_ph) else current_ph
    current_temp = None if pd.isna(current_temp) else current_temp
    current_rainfall = None if pd.isna(current_rainfall) else current_rainfall

    if soil_moisture_pred is not None and not pd.isna(soil_moisture_pred) and 0 <= soil_moisture_pred <= 100:
        if all(v is not None for v in [current_ph, current_temp, current_rainfall]):
            seed_recommendation = recommend_seeds_backend(current_ph, current_temp, current_rainfall, soil_moisture_pred)
            return jsonify({'recommendation': seed_recommendation})
        else:
            return jsonify({'recommendation': SEED_RECOMMENDATIONS_MESSAGES['no_specific'] + " (Missing current sensor data: pH, temperature, or rainfall)"})
    else:
        return jsonify({'recommendation': SEED_RECOMMENDATIONS_MESSAGES['no_specific'] + " (Predicted soil moisture is out of typical range or not available, hindering specific crop suggestions.)"})

@app.route('/api/voice_alert', methods=['POST'])
def api_voice_alert():
    data = request.get_json()
    text = data.get('text')
    lang = data.get('lang', 'en')

    if not text:
        return jsonify({'error': 'No text provided for speech generation.'}), 400

    audio_bytes, error_msg = speak_tip_backend(text, lang)
    if error_msg:
        return jsonify({'error': error_msg}), 500
    
    return send_file(
        io.BytesIO(audio_bytes),
        mimetype='audio/mpeg',
        as_attachment=False,
        download_name='alert.mp3'
    )

@app.route('/api/crop_labels')
def get_crop_labels():
    return jsonify({'crop_labels': all_crop_labels})

if __name__ == '__main__':
    # Initialize app components (models, scalers, Firebase, etc.)
    with app.app_context():
        initialize_app_components()

    # Start camera simulator in a separate thread
    camera_thread = threading.Thread(target=run_camera_simulator)
    camera_thread.daemon = True # Allow main program to exit even if threads are running
    camera_thread.start()

    # Start sensor data inserter in a separate thread
    sensor_inserter_thread = threading.Thread(target=run_sensor_data_inserter)
    sensor_inserter_thread.daemon = True
    sensor_inserter_thread.start()

    # The Flask app will be run by Gunicorn in a production environment,
    # so app.run() is not needed here.
    # port = int(os.environ.get("PORT", 5000))
    # app.run(host="0.0.0.0", port=port, debug=True)
